import * as path from 'path';
import * as fs from 'fs';
import * as https from 'https';
import * as url from 'url';
import Paths from '../../paths/paths';
import Logger from '../../utils/logger';
import * as jspm from 'jspm';

import { CdnJsApi, PackageItem, JspmPaths } from './jspm-cdn-paths-contacts';

const CDN_API = {
    Hostname: "api.cdnjs.com",
    Pathname: "libraries",
    Query: { fields: "assets,version", search: undefined } as { fields: string, search: string | undefined }

};

export default class JspmCdnPaths {

    public async Start(done: () => void) {
        let packagesList = this.getPackagesList();
        let paths = await this.startDownload(packagesList);
        if (paths != null && Object.keys(paths).length !== 0) {
            await this.saveResultToFile(paths);
        }
        done();
    }

     private async saveResultToFile(paths: JspmPaths) {
        let logger = Logger.withType("JSPM");
        return new Promise(resolve => {
            let pathname = path.join(Paths.Directories.Source, "configs", "jspm.config.production.js");
            logger.info(`Generating file '${pathname}'`);
            let data = [
                "/* Generated by simplr-gulp */",
                "SystemJS.config({",
                "    paths: " + JSON.stringify(paths, null, 4),
                "});"

            ].join("\r\n");
            fs.writeFile(pathname, data, (err) => {
                if (err) {
                    logger.error(err.message);
                }
                resolve();
            });
        });
    }

    private async startDownload(packagesList: Array<PackageItem>, paths: JspmPaths = {}) {
        return new Promise<JspmPaths>(async resolve => {
            if (packagesList.length > 0) {
                let item = packagesList.shift() !;
                let cdnLink = await this.getCdnLink(item);
                if (cdnLink !== undefined) {
                    paths[item.FullName] = cdnLink.replace(/^https?\:/i, "");
                }
                resolve(await this.startDownload(packagesList, paths));
            } else {
                resolve(paths);
            }
        });
    }


    private async getCdnLink(packageItem: PackageItem, splited: boolean = false) {
        return new Promise<string | undefined>(resolve => {

            let logger = Logger.withType(`JSPM [${packageItem.FullName}]`);

            let requestDetails = {
                protocol: "https:",
                hostname: CDN_API.Hostname,
                pathname: CDN_API.Pathname,
                query: CDN_API.Query
            };
            requestDetails.query.search = packageItem.Details.Name;

            let path = url.format(requestDetails);

            logger.info(`Downloading '${path}'`);

            let request = https.get(path, response => {
                logger.info(`Response '${response.statusCode}' (${response.statusMessage}).`);
                let allData = "";
                response.on("data", (data: string) => {
                    allData += data;
                });
                response.on('end', async () => {
                    let parsedJson: CdnJsApi.ResponseDto | undefined;
                    try {
                        parsedJson = JSON.parse(allData);
                    } catch (err) {
                        logger.error(`Sorry, something wrong with response data from ${CDN_API.Hostname}. Please report a bug.`);
                    };
                    if (parsedJson !== undefined) {
                        logger.info(`Downloaded and parsed '${parsedJson.total}' result${(parsedJson.total > 1) ? 's' : ''}.`);
                        if (parsedJson.total > 0) {
                            let link = await this.getLinkFromResponseByVersion(packageItem, parsedJson, splited);
                            if (link !== undefined) {
                                logger.info(`Cdn link successfully resolved.`);
                                logger.info(`'${link}'`);
                            } else {
                                logger.warn(`Cannot resolve cdn link with version ${packageItem.Details.Version}.`);
                            }
                            resolve(link);
                        } else {
                            if (!splited) {
                                let splitedName = this.tryToSplitPackageName(packageItem.Details.Name);
                                if (splitedName !== undefined) {
                                    logger.info(`Trying to use splited package name: '${splitedName}'`);
                                    let splitedPackageItem = {
                                        FullName: packageItem.FullName,
                                        MapName: packageItem.MapName,
                                        Details: {
                                            OriginalName: packageItem.Details.Name,
                                            Name: splitedName,
                                            Version: packageItem.Details.Version
                                        }
                                    };
                                    let link = this.getCdnLink(splitedPackageItem, true);
                                    resolve(link);
                                } else {
                                    resolve(undefined);
                                }
                            } else {
                                resolve(undefined);
                            }
                        }
                    } else {
                        resolve(undefined);
                    }
                });
            });

            request.on('error', (err: any) => {
                logger.error(err.message);
                resolve(undefined);
            });
        });
    }

    private tryToResolveSplitedPackage(packageItem: PackageItem, assetIndex: number, found: CdnJsApi.ItemDto, link: string | undefined = undefined): undefined | string {
        let logger = Logger.withType(`JSPM [${packageItem.FullName}]`);

        let asset = found.assets[assetIndex];
        let searchingFiles = new Array<string>();
        let originalName = packageItem.Details.OriginalName!.toLowerCase();
        // Searching .min.js or .js by order priority
        searchingFiles.push(`${originalName}.min.js`);
        searchingFiles.push(`${originalName}.js`);

        let foundFile = asset.files.find(x => searchingFiles.findIndex(y => y === x) !== -1);
        if (foundFile !== undefined) {
            logger.info(`File '${foundFile}' found.`);
            return this.buildCdnLinkWithCustomFile(link || found.latest, foundFile);
        }
        return undefined;
    }

    private tryToSplitPackageName(name: string): string | undefined {
        let splited = name.split("-");
        if (splited.length === 2) {
            return splited[0];
        }
        return undefined;
    }

    private async getLinkFromResponseByVersion(packageItem: PackageItem, responseDto: CdnJsApi.ResponseDto, splited: boolean) {
        let logger = Logger.withType(`JSPM [${packageItem.FullName}]`);

        return new Promise<string | undefined>(async resolve => {
            let found = responseDto.results.find(x => x.name === packageItem.Details.Name);
            if (found !== undefined) {
                if (found.version === packageItem.Details.Version) {
                    logger.info(`Version '${found.version}' found.`);
                    if (!splited) {
                        resolve(found.latest);
                    } else {
                        let foundAsset = found.assets.findIndex(x => x.version === packageItem.Details.Version);
                        if (foundAsset !== -1) {
                            resolve(this.tryToResolveSplitedPackage(packageItem, foundAsset, found));
                        } else {
                            resolve(undefined);
                        }
                    }
                } else {
                    logger.info(`Not targeting the latest version '${found.version}', trying to find version '${packageItem.Details.Version}'`);
                    let assetIndex = found.assets.findIndex(x => x.version === packageItem.Details.Version);
                    if (assetIndex !== undefined) {
                        let asset = found.assets[assetIndex];
                        logger.info(`Version '${packageItem.Details.Version}' found.`);
                        let link = this.buildCdnLink(found.latest, found.version, packageItem.Details.Version);
                        if (link !== undefined) {
                            if (splited) {
                                resolve(this.tryToResolveSplitedPackage(packageItem, assetIndex, found, link));
                            } else {
                                let fileName = path.parse(link).base;
                                logger.info(`Checking file '${fileName}'`);
                                if (asset.files.findIndex(x => x === fileName) !== -1) {
                                    logger.info(`File '${fileName}' found.`);
                                    resolve(link);
                                } else {
                                    logger.info(`File '${fileName}' does not exist in '${packageItem.Details.Version}' version.`);
                                    resolve(undefined);
                                }
                            }
                        } else {
                            logger.error([
                                "Failed to resolve cdn link. Please report this error.",
                                `--- ERROR DETAILS ---`,
                                `LatestLink: ${found.latest}`,
                                `LatestVersion: ${found.version}`,
                                `TargetVersion:  ${packageItem.Details.Version}`,
                                `---------------------`
                            ].join("\r\n "));
                            resolve(link);
                        }
                    } else {
                        resolve(undefined);
                    }
                }
            } else {
                resolve(undefined);
            }
        });
    }

    private buildCdnLinkWithCustomFile(latestLink: string, targetFile: string) {
        let currentFileName = path.parse(latestLink).base;
        return latestLink.replace(currentFileName, targetFile);
    }

    private buildCdnLink(latestLink: string, latestVersion: string, targetVersion: string) {
        let linkDetails = latestLink.split(latestVersion);
        if (linkDetails.length === 2) {
            let link = linkDetails[0] + targetVersion + linkDetails[1];
            return link;
        } else {
            return undefined;
        }
    }

    private getPackagesList(registry: string = "npm") {
        let prefix = `${registry}:`;
        let packagesList = new Array<PackageItem>();

        jspm.setPackagePath('.');
        let packagesMap: { [name: string]: string } = jspm.Loader().getConfig().map;

        for (let name in packagesMap) {
            let fullName = packagesMap[name];
            if (fullName.indexOf(prefix) === 0) {
                let details = fullName.slice(prefix.length, fullName.length).split("@");
                packagesList.push({
                    MapName: name,
                    FullName: fullName,
                    Details: {
                        Name: details[0],
                        Version: details[1]
                    }
                });
            }
        }

        return packagesList;
    }



}
